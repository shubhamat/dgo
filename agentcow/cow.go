/* (c) 2017  Shubham Mankhand  <shubham.mankhand@gmail.com> */
package main

import (
	"container/list"
	"encoding/gob"
	"flag"
	"fmt"
	"math/rand"
	"net"
	"net/http"
	"net/rpc"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

type WorkItem struct {
	Duration int
	Cost     int
	Origin   int
}

type workQueue struct {
	mutex sync.Mutex
	list  list.List
}

/* For RPC */
type ArgsNotUsed int
type CowRPC int

/* -1 implies sow thread will keep sowing */
const defWorkItems = -1
const defWorkItemsOutFile = 100
const defMaxWorkDuration = 11
const defMaxWorkCost = 101
const defMaxSowSleep = 6
const (
	origin_local  = 1
	origin_remote = 2
)

const port = ":23432"
const defIface = "wlan0"

var myip string
var myipaddr *net.IPNet
var broadcast string

var cows []string
var herdwqmap map[string]int
var wq = workQueue{}
var localItems, remoteItems int
var startTime time.Time
var wg sync.WaitGroup

var launchSow = flag.Bool("sow", false, "Start sow thread")
var iface = flag.String("iface", defIface, "Interface used for sending data")
var outfile = flag.String("sow-of", "", "Output file for storing workitems")
var infile = flag.String("eat-if", "", "Input file  for filling work queue with work items")
var workItems = flag.Int("work-items", defWorkItems, "Number of work items to be generated by sow thread")
var maxWorkDuration = flag.Int("max-work-duration", defMaxWorkDuration, "Max duration of work items generated by sow thread")

func main() {

	initAll()

	wg.Add(1)
	go moo()

	wg.Add(1)
	go discover()

	wg.Add(1)
	go beDiscovered()

	if *launchSow {
		wg.Add(1)
		go sow()
	}

	wg.Add(1)
	go eat()

	wg.Wait()
}

func initAll() {

	startTime = time.Now()

	/* Process the command line flags */
	flag.Parse()

	if *launchSow && *outfile != "" {
		fmt.Fprintf(os.Stderr, "-sow and -sow-of cannot be used together\n")
		os.Exit(1)
	}

	if *launchSow && *infile != "" {
		fmt.Fprintf(os.Stderr, "-sow and -eat-if cannot be used together\n")
		os.Exit(1)
	}

	if *outfile != "" && *infile != "" {
		fmt.Fprintf(os.Stderr, "-sow-of and -eat-if cannot be used together\n")
		os.Exit(1)
	}

	if !*launchSow && *outfile == "" && *workItems != -1 {
		fmt.Fprintf(os.Stderr, "-work-items should be used with -sow or -sow-of\n")
		os.Exit(1)
	}

	if *outfile != "" {
		if *workItems == -1 {
			*workItems = defWorkItemsOutFile
		}
		sowToFile(*outfile)
	}

	if *infile != "" {
		eatFromFile(*infile)
	}

	/* Setup signal handler:  on a ctrl+c print report and exit*/
	wg.Add(1)
	go doSignals()

	/* Setup network properties */
	myiface, err := net.InterfaceByName(*iface)

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error in locating interface:%s\n%s\n", *iface, err)
		os.Exit(1)
	}

	addresses, err := myiface.Addrs()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error in getting address for interface:%s\n%s\n", *iface, err)
		os.Exit(1)
	}

	for _, addr := range addresses {
		if ipaddr, ok := addr.(*net.IPNet); ok && !ipaddr.IP.IsLoopback() {
			if ipaddr.IP.To4() != nil {
				myip = ipaddr.IP.String()
				myipaddr = ipaddr
			}
		}
	}

	ip := myipaddr.IP.To4()
	mask := myipaddr.Mask
	bcast := make(net.IP, len(ip))
	for i := range bcast {
		bcast[i] = ip[i] | ^mask[i]
	}

	broadcast = fmt.Sprintf("%s", bcast)

	if myip == "" {
		fmt.Println("You must specify an interface.  Usage:  cow -iface <InterfaceName>")
		os.Exit(1)
	}

	herdwqmap = make(map[string]int, len(cows))

	rand.Seed(time.Now().UTC().UnixNano())

	fmt.Printf("Initialized cow:%s..., Looking for other cows on:%s\n", myip, broadcast)
}

/*
 * Discover new cows.
 */
func discover() {
	defer wg.Done()

	fmt.Println("[DISCOVER:" + myip + "] Launched thread")
	svc := "0.0.0.0" + port
	addr, err := net.ResolveUDPAddr("udp4", svc)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	conn, err := net.ListenUDP("udp", addr)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	for {
		var buf [64]byte
		_, cowaddr, err := conn.ReadFromUDP(buf[0:])
		if err != nil {
			fmt.Println("DISCOVER read error")
			time.Sleep(time.Second)
			continue
		}
		newcowaddr := cowaddr.IP.String()
		if newcowaddr == myip {
			continue
		}

		found := false
		for i := 0; i < len(cows); i++ {
			if cows[i] == newcowaddr {
				found = true
				break
			}
		}

		if !found {
			cows = append(cows, newcowaddr)
			fmt.Printf("[DISCOVER:%s] Adding new cow %s. Total cows in herd %d\n", myip, newcowaddr, 1+len(cows))
			herdwqmap[newcowaddr] = 0
			wg.Add(1)
			go wander(newcowaddr)
		}
	}
}

func doSignals() {
	defer wg.Done()
	sigchan := make(chan os.Signal, 1)
	signal.Notify(sigchan, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL, syscall.SIGQUIT)
	<-sigchan
	printReportAndExit()
}

/*
 * Let other cows know you exist
 */
func beDiscovered() {
	defer wg.Done()
	fmt.Println("[BEDISCOVERED:" + myip + ":" + broadcast + "] Launched thread")
	for {
		svc := broadcast + port
		addr, err := net.ResolveUDPAddr("udp4", svc)
		if err != nil {
			fmt.Println("BEDISCOVERED resolve error")
			time.Sleep(time.Second)
			continue
		}

		conn, err := net.DialUDP("udp", nil, addr)
		if err != nil {
			fmt.Println("BEDISCOVERED dial error")
			time.Sleep(time.Second)
			continue
		}
		conn.Write([]byte("cow"))
		conn.Close()
		time.Sleep(time.Second)
	}
}

func dequeue() WorkItem {
	wq.mutex.Lock()
	e := wq.list.Front()
	if e == nil {
		wq.mutex.Unlock()
		defer forage()
		return WorkItem{}
	}
	work := e.Value.(WorkItem)
	wq.list.Remove(e)
	wq.mutex.Unlock()
	return work
}

func dequeueLocal() WorkItem {
	wq.mutex.Lock()
	e := wq.list.Front()
	if e == nil {
		wq.mutex.Unlock()
		return WorkItem{}
	}
	work := e.Value.(WorkItem)
	if work.Origin == origin_local {
		wq.list.Remove(e)
	} else {
		work = WorkItem{}
	}
	wq.mutex.Unlock()
	return work
}

func (t *CowRPC) GetQueueLen(_ *ArgsNotUsed, reply *int) error {
	wq.mutex.Lock()
	*reply = wq.list.Len()
	wq.mutex.Unlock()
	return nil
}

func (t *CowRPC) GetWorkItem(_ *ArgsNotUsed, reply *WorkItem) error {
	*reply = dequeueLocal()
	return nil
}

func eat() {
	defer wg.Done()
	fmt.Println("[EAT:" + myip + "] Launched thread")

	for {
		work := dequeue()
		if work == (WorkItem{}) {
			/* When processing data off a file, print a report on time taken to process all items. */
			if *infile != "" {
				printReportAndExit()
			}
			if !*launchSow {
				time.Sleep(time.Millisecond * 100)
			}
		} else {
			switch work.Origin {
			case origin_local:
				localItems++
			case origin_remote:
				remoteItems++
			}
			fmt.Printf("[EAT:%s qlen:%d] Processing work of Duration:%d\n", myip, wq.list.Len(), work.Duration)
			time.Sleep(time.Second * time.Duration(work.Duration))
		}
	}

}

func eatFromFile(filename string) {
	fmt.Printf("[EAT:%s] Filling work queue from file:%s\n", myip, filename)

	work := WorkItem{}

	file, err := os.Open(filename)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	dec := gob.NewDecoder(file)
	n := 0
	for dec.Decode(&work) == nil {
		wq.mutex.Lock()
		wq.list.PushBack(work)
		wq.mutex.Unlock()
		n++
		fmt.Printf("[EATFROMFILE:%s qlen:%d] Added work item %d  (Duration = %d)\n", myip, wq.list.Len(), n, work.Duration)
	}
	*workItems = n
}

/* Print Report */
func printReportAndExit() {
	delta := time.Since(startTime)
	fmt.Printf("\n[COW:%s] Took %d seconds to process %d local items and %d remote items\n",
		myip, int(delta.Seconds()), localItems, remoteItems)
	os.Exit(0)
}

/* Load Generators */

func sow() {
	defer wg.Done()
	fmt.Println("[SOW:" + myip + "] Launched thread")
	n := 0
	for {
		/* Sleep for a random time */
		sleep_time := rand.Intn(defMaxSowSleep)
		time.Sleep(time.Second * time.Duration(sleep_time))
		Duration := rand.Intn(*maxWorkDuration + 1)
		Cost := rand.Intn(defMaxWorkCost)
		work := WorkItem{Duration, Cost, origin_local}
		wq.mutex.Lock()
		wq.list.PushBack(work)
		wq.mutex.Unlock()
		fmt.Printf("[SOW:%s qlen:%d] Added work item %d  (Duration = %d)\n", myip, wq.list.Len(), n, work.Duration)
		n++
		if *workItems != -1 && n > *workItems {
			fmt.Println("[SOW:" + myip + "] Exiting thread")
			return
		}
	}

}

func sowToFile(filename string) {
	fmt.Printf("[SOW] Sowing %d work items to file:%s\n", *workItems, filename)

	file, err := os.Create(filename)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}

	enc := gob.NewEncoder(file)

	for n := 0; n < *workItems; n++ {
		Duration := rand.Intn(*maxWorkDuration + 1)
		Cost := rand.Intn(defMaxWorkCost)
		work := WorkItem{Duration, Cost, origin_local}
		enc.Encode(work)
		fmt.Printf("[SOWTOFILE:%s] Added work item %d  (Duration = %d)\n", filename, n, work.Duration)
	}

	file.Close()

	os.Exit(0)
}

func moo() {
	defer wg.Done()
	cowrpc := new(CowRPC)
	rpc.Register(cowrpc)
	rpc.HandleHTTP()
	listener, err := net.Listen("tcp", port)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(3)
	}

	fmt.Println("[MOO:" + myip + "] Starting HTTP Server for RPC")
	wg.Add(1)
	go http.Serve(listener, nil)
}

/*
 * Wander and fetch the queue len for the given cow.
 * One thread for each cow in cows[]
 */
func wander(cowip string) {
	defer wg.Done()
	fmt.Println("[WANDER:" + myip + "] Launched thread for " + cowip)

	for {
		client, err := rpc.DialHTTP("tcp", cowip+port)
		if err != nil {
			time.Sleep(time.Second * 2)
			continue
		}
		qlen := 0
		notUsed := 0
		/* Ignore error for now */
		err = client.Call("CowRPC.GetQueueLen", &notUsed, &qlen)
		herdwqmap[cowip] = qlen
		time.Sleep(time.Second)
	}
}

/*
 * Get work off another cow's queue
 */
func forage() {
	defer wg.Done()
	if len(cows) < 1 {
		return
	}

	var max int = herdwqmap[cows[0]]
	var maxcowip string = cows[0]

	for i := 1; i < len(cows); i++ {
		if max < herdwqmap[cows[i]] {
			max = herdwqmap[cows[i]]
			maxcowip = cows[i]
		}
	}

	client, err := rpc.DialHTTP("tcp", maxcowip+port)
	if err != nil {
		return
	}
	var work WorkItem
	notUsed := 0
	err = client.Call("CowRPC.GetWorkItem", &notUsed, &work)

	if work != (WorkItem{}) {
		fmt.Printf("[FORAGE:%s] Added work from %s, qlen:%d\n", myip, maxcowip, max)
		work.Origin = origin_remote
		wq.mutex.Lock()
		wq.list.PushBack(work)
		wq.mutex.Unlock()
	}
}
